# Chapter2 线性结构

### 2.1 线性表及其实现

如何表示多项式 
$$
f(x)=4x^5-3x^2+1
$$

1. 可用array表示：

​	 **a[i]**: 第i+1项的系数

​		存在问题：如果多项式存在x的2002次，但其他系数为0，空间很浪费。

2. 用struct表示
3. Linked-list(链表)

------

**线性表(Linear List)**: 由同类型数据元素构成有序序列的线性结构

1. Array(数组)
2. Linked-List(链表)

------

**广义表(Generalized List)**是线性表的推广，对于线性表而言，n个元素都是基本的单元素。广义表中，这些元素不仅可以是单元素也可以是另一个广义表。

例：二元多项式的表示

**多重链表** 多重链表中结点(Node)的指针域会有多个，但包含两个指针域的链表不一定是多重链表（双向链表）

多重链表在树，图里面有广泛应用。

### 2.2 堆栈(Stack)

例：计算机如何进行表达式求值

中缀表达式：运算符号位于两个运算数之间。a+b*c-d/e

后缀表达式：运算符号位于两个运算数之后。abc*+de/-

​	从左往右扫描，逐个处理运算数和运算符号。

​	**启示**：需要一种存储方法，能顺序储存运算数，并在需要时倒叙输出

------

**堆栈**；具有一定操作约束的线性表

- 只在一端（栈顶，Top）做插入、删除
- 插入数据：入栈（Push）
- 删除数据：出栈（Pop）
- 先入后出：Last in First out(LIFO)

------

栈的顺序存储实现

​	栈的顺序存储结构通常由一个一维数组和一个记录栈顶元素位置的变量组成

```c
#define MaxSize
typedef struct SNode *Stack;
struct SNode{
	ElementType Data[MaxSize];
	int Top;
}
```

------

堆栈的链式存储实现

​	栈的链式存储结构实际上就是一个单链表，叫做链栈。插入和删除操作只能在链栈的栈顶进行。

​	**注意**： Top是链表的头

------

**如何将中缀表达式转换成后缀表达式** - 从头到尾读取中缀表达式的每个对象，对不同对象按不同的情况处理

1. 运算数：直接输出

2. 左括号：压入堆栈

3. 右括号：将栈顶的运算符号弹出并输出，直到遇到左括号（出栈，不输出）

4. 运算符：

   ​	-若优先级大于栈顶运算符时，则把它压栈

   ​	-若优先级小于等于栈顶运算符时，将栈顶运算符弹出并输出；再比较新的栈顶运算符，直到该运算符大于栈顶运算符优先级为止，然后将该运算符压栈

5. 若各对象处理完毕，则把堆栈中的运算符一并输出

------

堆栈其他应用：

- 函数调用及递归实现
- 深度优先搜索
- 回溯算法 （例：老鼠走迷宫）

### 2.3 队列(Queue)

**队列**：具有一定操作约束的线性表

数据插入：入队列（AddQ）

数据删除：出队列（DeleteQ)

先进先出：FIFO

------

队列的顺序存储实现

​	队列的顺序存储结构通常由一个一位数组和一个记录队列头元素位置的变量front以及一个记录队列尾元素位置的变量rear组成。

```c
#define MaxSize
struct QNode {
  ElementType Data[MaxSize];
  int front; // front 指向第一个元素的前一个位置
  int rear;	// rear 指向最后一个元素所在位置
};
typedef struct QNode *Queue;
```

为解决空间浪费问题，引入“顺环队列”

------

队列的链式存储实现

​	队列的链式存储结构也可以用一个单链表实现。插入和删除操作分别在链表的两头进行；

```c
struct Node{
  ElementType Data;
  struct Node *Next;
};
struct QNode{
  struct Node *rear;
  struct Node *front;
};
typedef struct QNode *Queue;

```

### 2.4 应用实例：多项式加法运算

